## @section Percona Monitoring and Management (PMM) parameters
## Default values for PMM.
## This is a YAML-formatted file.
## Declare variables to be passed into your templates.

## PMM image version
## ref: https://hub.docker.com/r/percona/pmm-server/tags
## @param image.repository PMM image repository
## @param image.pullPolicy PMM image pull policy
## @param image.tag PMM image tag (immutable tags are recommended)
## @param image.imagePullSecrets Global Docker registry secret names as an array
##
image:
  repository: perconalab/pmm-server-fb
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "PR-3952-c7243ba"
  imagePullSecrets: []

## PMM environment variables
## ref: https://docs.percona.com/percona-monitoring-and-management/setting-up/server/docker.html#environment-variables
##
pmmEnv:
  ## @param pmmEnv.PMM_ENABLE_UPDATES: false Disables a periodic check for new PMM versions as well as ability to apply upgrades using the UI (need to be disabled in k8s environment as updates rolled with helm/container update)
  ##
  PMM_ENABLE_UPDATES: 'false'
#  optional variables to integrate Grafana with internal iDP, see also secret part
#  GF_AUTH_GENERIC_OAUTH_ENABLED: 'true'
#  GF_AUTH_GENERIC_OAUTH_SCOPES: ''
#  GF_AUTH_GENERIC_OAUTH_AUTH_URL: ''
#  GF_AUTH_GENERIC_OAUTH_TOKEN_URL: ''
#  GF_AUTH_GENERIC_OAUTH_API_URL: ''
#  GF_AUTH_GENERIC_OAUTH_ALLOWED_DOMAINS: ''

## @param pmmResources optional [Resources](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) requested for [PMM container](https://docs.percona.com/percona-monitoring-and-management/setting-up/server/index.html#set-up-pmm-server)
    ##  pmmResources:
    ##    requests:
    ##      memory: "32Gi"
    ##      cpu: "8"
    ##    limits:
    ##      memory: "64Gi"
    ##      cpu: "32"
pmmResources: {}

## Readiness probe Config
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
## @param readyProbeConf.initialDelaySeconds  Number of seconds after the container has started before readiness probes is initiated
## @param readyProbeConf.periodSeconds How often (in seconds) to perform the probe
## @param readyProbeConf.failureThreshold When a probe fails, Kubernetes will try failureThreshold times before giving up
##
readyProbeConf:
  initialDelaySeconds: 1
  periodSeconds: 5
  failureThreshold: 6

## @section PMM secrets
##
secret:
  ## @param secret.name Defines the name of the k8s secret that holds passwords and other secrets
  ##
  name: pmm-secret
  ## @param secret.annotations -- Secret annotations configuration
  annotations: {}
  ## @param secret.create If true then secret will be generated by Helm chart. Otherwise it is expected to be created by user.
  ##
  create: true
  ## @param secret.pmm_password Initial PMM password - it changes only on the first deployment, ignored if PMM was already provisioned and just restarted. If PMM admin password is not set, it will be generated.
  ## E.g.
  ## pmm_password: admin
  ##
  ## To get password execute `kubectl get secret pmm-secret -o jsonpath='{.data.PMM_ADMIN_PASSWORD}' | base64 --decode`
  ##
  pmm_password: ""
  ##
  # GF_AUTH_GENERIC_OAUTH_CLIENT_ID optional client ID to integrate Grafana with internal iDP, requires other env defined as well under pmmEnv
  # GF_AUTH_GENERIC_OAUTH_CLIENT_ID:
  # GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET optional secret to integrate Grafana with internal iDP, requires other env defined as well under pmmEnv
  # GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET:

## @param certs Optional certificates, if not provided PMM would use generated self-signed certificates,
##   please provide your own signed ssl certificates like this in base 64 format:
certs:
 name: pmm-certs
 files:
  certificate.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMxekNDQWIrZ0F3SUJBZ0lVTFBQak5ha1ZoZVZUdHpmakFoanJiaFY3Y0g0d0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZERVNNQkFHQTFVRUNnd0pUV0ZwYmlCUGNtY3VNQjRYRFRJMU1EWXdOVEl5TlRJek1sb1hEVEkyTURZdwpOVEl5TlRJek1sb3dGREVTTUJBR0ExVUVDZ3dKVFdGcGJpQlBjbWN1TUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGCkFBT0NBUThBTUlJQkNnS0NBUUVBMmRhOXMyOVBONDd2TTd5STJ3RDRhM1BTVzY1RWozT2lHTkVZeU5BSXcxdnkKbjZJdThDY3djMVZJdXRjc05WcGpsNHhqdFBJejhyS2ZPa1hYTTdrbTNrUWFIVzM3QXpUdm4rTjhpdTJDbmtVdQpWVHR6SHNQOUR6NmFmOFNkb0ZxTC9iQjkrUnZIaUpsdms4azVJVmc4UEVoY05IdGJiSkVvT2djVUI1TVBOMW1jCkxKUmJrUWlJRllmR2x6T3duMlhzbDRieWVtMmFXR0pVWFgxbjdaMll4UmFhYTI0YjJHR2RHVjljTnYyczFnUmgKREYvc3dQRitPRTI5ZVR3WUdrYTdNRGVqdjUzT2Z1U010K1NvdGRGVEJsV29vc0FEd0FZSjdwSGNIejdRZnV2cQoxZGsySXhINnNjUFk4NUw2MkhTTTJiZ0h5Tll2dnZ4MGdQcGt3UkEybFFJREFRQUJveUV3SHpBZEJnTlZIUTRFCkZnUVVXQmdDUkgvbWtxSzJHOGErcGMvcDVyOXF3akF3RFFZSktvWklodmNOQVFFTEJRQURnZ0VCQUozMHMzbjcKdGNGcm5BWitETlBvY3BXMCtpWEh0dGJVSUMyOXVkYWprd0cxQjYwM3VWUWRmcHRNNlN4VjZPcVdiTnJPU2VIbApVOVNrYURoeldobCtBWERpc1MzbjZiOGZWUHhRak9qTkpBZFpGMTJJZ2V5VzllaGRVRkZpVHdHNUNiOFAzVGdBCllXNlRuTERGeVBzNnJwMW1mSkZuQmJzRFRPRWxCcTZJdTFQbWlRLzUwTFgyRmcyOWJpUTcrRUdDVW4vakUxeloKbzduOWJLZkpVMEhWdjRnVVBUMjRlRHdqY1YrQTR1T3BDandxT21wanByQlBlRFVweGE4NGQ4Vk5zUVpPMlQ4cwplOFpaQ0JDbUFjT1M3bFN0bGJOVEV6WTlYUVhyaVJDc1ZjNWhpbVVueGxNZUtTR3JyTm9PVW5wTlNhRVdJV0dBCk4wd2xKaXc0SjA2d0xlYz0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
  certificate.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktnd2dnU2tBZ0VBQW9JQkFRRFoxcjJ6YjA4M2p1OHoKdklqYkFQaHJjOUpicmtTUGM2SVkwUmpJMEFqRFcvS2ZvaTd3SnpCelZVaTYxeXcxV21PWGpHTzA4alB5c3A4NgpSZGN6dVNiZVJCb2RiZnNETk8rZjQzeUs3WUtlUlM1Vk8zTWV3LzBQUHBwL3hKMmdXb3Y5c0gzNUc4ZUltVytUCnlUa2hXRHc4U0Z3MGUxdHNrU2c2QnhRSGt3ODNXWndzbEZ1UkNJZ1ZoOGFYTTdDZlpleVhodko2YlpwWVlsUmQKZldmdG5aakZGcHByYmh2WVlaMFpYMXcyL2F6V0JHRU1YK3pBOFg0NFRiMTVQQmdhUnJzd042Ty9uYzUrNUl5Mwo1S2kxMFZNR1ZhaWl3QVBBQmdudWtkd2ZQdEIrNityVjJUWWpFZnF4dzlqemt2cllkSXpadUFmSTFpKysvSFNBCittVEJFRGFWQWdNQkFBRUNnZ0VBQ0IvY2NPQUdwQk9TWTh0VkRsZjFxK3BFcnZNcnJ1NzQzWFNVK0U1YitVOUoKVi85UVFWZ3cxQ2hhMzA4Tm9NckhlcHc3anNEV3c2YzZUWTNUeGlQU2FZbEFNUmRNUEpVaGw4Uy8vUjE1R09hTApJUllueDc2M0JqWEhSTnNrSnRvaHJQdERZNEpQK1k0QmJaRmNibHd3V080NDlDTWlxSVNzYTZlZWJWN2tleU9zCmpvVmRCdS95aXBsRGJkVTZ1eVVISWZQQ0U3ZlJnVEJTL2ZtREE4ZkNWWE1Wa1UraHZxNWtMWmNsWDZuWVIyYXUKM01Eb3gvWDNCMU1VV281aVpxTmMyVkNUU1NaaUlPVkpGdCtlNnd6anpJcHpCQ1RxeWovNmJDVGwxKzRiSWJLbQpmMzlMdGNEbXBUOHZuSitiTHBhVHdsTTJvZmNvbWpZcWhzamhvOWhkV1FLQmdRRDRYVWVHN0dnM1p5QlRDbnRyCnAzT2Y0UU5yRDVhSlNKK2U2QU9wWUFvU2EwWmQ3bFQ5TTZEZ1lLcFNlcUpnU3VGb1pJTEpReWRZbVp1N3RabFgKRUVzR1JoSnpyeGpZcDZkM3k3UUZZTFJFUFB6dVA5K2VBR2hKZVZtM0lPS3NaS2JIYklaY29zSFJKeXRIUDlNawpkdWRFUG1rOUFZU1I0R1NoZUJiYnp2ajZpUUtCZ1FEZ2lUYlV4TWhnOW51T3hWYkhzUmVId24zRDlQOVFiUVQyCkdoRXhjWTZYSE9SZXNpQTFyY1dsK0RpNGV4d1NKMkZDNjM2Y2NzcjFzd0N5Y0Y5SVd1UGF3Z29hWXdpSURIUUwKRmtXTitZUWlKTWZzMVRQVGhTVkpyTVl4aHd1UkV3bzY3MjdZUFQ2YWU3Y0pMRTJyZUxLUExybmN6UEdyK0ZSMApWU3dTZmYyb3JRS0JnUURodjErUld2YUxUVGhMWXA2MlJubEpYQ3hRTnRYOHFMODFuK3djR3doc240ZFJQNTJPCm5FdmhSdHZwcGtCTFNDVEVUMysxVWszRU1iTWxGalp2dFlhTUNFc2pUWWRHL25TdzViNFdtVVNoTmRJcytHL1kKWE1SdDdGaElwU0tEMGVUcUpWR25oK1NscUhXbENIVnhrb1k1T0lWTmgwQ3BtNDI4V3J4a1JTZDRDUUtCZ0daNgpXWnNjUVBQNEt3WkxUTU1STVZNVjBqNllWOXFHRjBpWE54ZWc0MXBXcG1nTjFpT0pydmFENXFkVUVNaThUbWl6CmdISzQ5YWJUenRLaDlPcmFDTHB6NnhhRjhvUGRZeTBZT2lDRksraEZielhKVE1FU09LVjZoRzVnVzBnWUw0Z2MKZFRPZUtDOXJuV3REWENPUmo3Vkh0eTV1SHpMRXdRN2pQSjBvQVpoMUFvR0JBS0FFbEw1K3lJTktxQ09CNnBsSQpDbUp6aHNraldEQXNncmx6dTlsZnBVNFpDSTFuOWdjMDR5N2VXdTFkYmNmTjdLcFJJSVY0bmZZM205WnNYVEwwCkFIYlRKdFR2SkhkN2JCMFV3NEFIazdrMllEUWQvY1FIZ21wTGdrZ1IvdFBSZ3ErNTMvSGJoQ1V1SUVydGRwdFUKenRhdzdpTVRhOUZEVUpGRkFnME9uK1FaCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K
  ca-certs.pem: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZhekNDQTFPZ0F3SUJBZ0lSQUlJUXo3RFNRT05aUkdQZ3UyT0Npd0F3RFFZSktvWklodmNOQVFFTEJRQXcKVHpFTE1Ba0dBMVVFQmhNQ1ZWTXhLVEFuQmdOVkJBb1RJRWx1ZEdWeWJtVjBJRk5sWTNWeWFYUjVJRkpsYzJWaApjbU5vSUVkeWIzVndNUlV3RXdZRFZRUURFd3hKVTFKSElGSnZiM1FnV0RFd0hoY05NVFV3TmpBME1URXdORE00CldoY05NelV3TmpBME1URXdORE00V2pCUE1Rc3dDUVlEVlFRR0V3SlZVekVwTUNjR0ExVUVDaE1nU1c1MFpYSnUKWlhRZ1UyVmpkWEpwZEhrZ1VtVnpaV0Z5WTJnZ1IzSnZkWEF4RlRBVEJnTlZCQU1UREVsVFVrY2dVbTl2ZENCWQpNVENDQWlJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dJUEFEQ0NBZ29DZ2dJQkFLM29KSFAwRkRmem01NHJWeWdjCmg3N2N0OTg0a0l4dVBPWlhvSGozZGNLaS92VnFidllBVHlqYjNtaUdiRVNUdHJGai9SUVNhNzhmMHVveG15RisKMFRNOHVrajEzWG5mczdqL0V2RWhta3ZCaW9aeGFVcG1abXlQZmp4d3Y2MHBJZ2J6NU1EbWdLN2lTNCszbVg2VQpBNS9UUjVkOG1VZ2pVK2c0cms4S2I0TXUwVWxYaklCMHR0b3YwRGlOZXdOd0lSdDE4akE4K28rdTNkcGpxK3NXClQ4S09FVXQrend2by83VjNMdlN5ZTByZ1RCSWxESENOQXltZzRWTWs3QlBaN2htL0VMTktqRCtKbzJGUjNxeUgKQjVUMFkzSHNMdUp2VzVpQjRZbGNOSGxzZHU4N2tHSjU1dHVrbWk4bXhkQVE0UTdlMlJDT0Z2dTM5NmozeCtVQwpCNWlQTmdpVjUrSTNsZzAyZFo3N0RuS3hIWnU4QS9sSkJkaUIzUVcwS3RaQjZhd0JkcFVLRDlqZjFiMFNIelV2CktCZHMwcGpCcUFsa2QyNUhON3JPckZsZWFKMS9jdGFKeFFaQktUNVpQdDBtOVNUSkVhZGFvMHhBSDBhaG1iV24KT2xGdWhqdWVmWEtuRWdWNFdlMCtVWGdWQ3dPUGpkQXZCYkkrZTBvY1MzTUZFdnpHNnVCUUUzeERrM1N6eW5UbgpqaDhCQ05BdzFGdHhOclFIdXNFd01GeEl0NEk3bUtaOVlJcWlveW1DekxxOWd3UWJvb01EUWFIV0JmRWJ3cmJ3CnFIeUdPMGFvU0NxSTNIYWFkcjhmYXFVOUdZL3JPUE5rM3NnckRRb28vL2ZiNGhWQzFDTFFKMTNoZWY0WTUzQ0kKclU3bTJZczZ4dDBuVVc3L3ZHVDFNME5QQWdNQkFBR2pRakJBTUE0R0ExVWREd0VCL3dRRUF3SUJCakFQQmdOVgpIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJSNXRGbm1lN2JsNUFGemdBaUl5QnBZOXVtYmJqQU5CZ2txCmhraUc5dzBCQVFzRkFBT0NBZ0VBVlI5WXFieXlxRkRRRExIWUdta2dKeWtJckdGMVhJcHUrSUxsYVMvVjlsWkwKdWJoekVGblRJWmQrNTB4eCs3TFNZSzA1cUF2cUZ5RldoZkZRRGxucnp1Qlo2YnJKRmUrR25ZK0VnUGJrNlpHUQozQmViWWh0RjhHYVYwbnh2d3VvNzd4L1B5OWF1Si9HcHNNaXUvWDErbXZvaUJPdi8yWC9xa1NzaXNSY09qL0tLCk5GdFkyUHdCeVZTNXVDYk1pb2d6aVV3dGhEeUMzKzZXVndXNkxMdjN4TGZIVGp1Q3ZqSElJbk56a3RIQ2dLUTUKT1JBekk0Sk1QSitHc2xXWUhiNHBob3dpbTU3aWF6dFhPb0p3VGR3Sng0bkxDZ2ROYk9oZGpzbnZ6cXZIdTdVcgpUa1hXU3RBbXpPVnl5Z2hxcFpYakZhSDNwTzNKTEYrbCsvK3NLQUl1dnRkN3UrTnhlNUFXMHdkZVJsTjhOd2RDCmpOUEVscHpWbWJVcTRKVWFnRWl1VERrSHpzeEhwRktWSzdxNCs2M1NNMU45NVIxTmJkV2hzY2RDYitaQUp6VmMKb3lpM0I0M25qVE9RNXlPZisxQ2NlV3hHMWJRVnM1WnVmcHNNbGpxNFVpMC8xbHZoK3dqQ2hQNGtxS09KMnF4cQo0Umdxc2FoRFlWdlRIOXc3alhieUxlaU5kZDhYTTJ3OVUvdDd5MEZmLzl5aTBHRTQ0WmE0ckYyTE45ZDExVFBBCm1SR3VuVUhCY25XRXZnSkJRbDluSkVpVTBac252Z2MvdWJoUGdYUlI0WHEzN1owajRyN2cxU2dFRXp3eEE1N2QKZW15UHhnY1l4bi9lUjQ0L0tKNEVCcytsVkRSM3ZleUptK2tYUTk5YjIxLytqaDVYb3MxQW5YNWlJdHJlR0NjPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlFcURDQ0E1Q2dBd0lCQWdJUkFKZ1Q5SFVUNVhVTFErZERIcGNlUkwwd0RRWUpLb1pJaHZjTkFRRUxCUUF3ClB6RWtNQ0lHQTFVRUNoTWJSR2xuYVhSaGJDQlRhV2R1WVhSMWNtVWdWSEoxYzNRZ1EyOHVNUmN3RlFZRFZRUUQKRXc1RVUxUWdVbTl2ZENCRFFTQllNekFlRncweE5URXdNVGt5TWpNek16WmFGdzB5TURFd01Ua3lNak16TXpaYQpNRW94Q3pBSkJnTlZCQVlUQWxWVE1SWXdGQVlEVlFRS0V3MU1aWFFuY3lCRmJtTnllWEIwTVNNd0lRWURWUVFECkV4cE1aWFFuY3lCRmJtTnllWEIwSUVGMWRHaHZjbWwwZVNCWU1UQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQUQKZ2dFUEFEQ0NBUW9DZ2dFQkFKelREUEJhNVM1SHQzSmRONE96YUdNdzZ0YzFKaGtsNGIyK05mRndraSszdUV0QgpCYXVwbmpVSVdPeXhLc1JvaHd1ajQzWGs1dk9uWW5HNmVZRmdIOWVSbXAvejBIaG5jY2hwRHBXUnovN21tZWxnClBFak1mc3BOZHhJa25VY2JXdXU1N0I0M0FCeWNySHVuQmVyT1N1dTlRZVUybUxuTC9XMDhsbWpmSXlwQ2tBeUcKZEdmSWY2V2F1RkpoRkJNL1plbUNoOHZiK2c1VzlvYUo4NFUvbDRhdnNOd2E3MnNObFJaOXhDdWdaYktaQkRaMQpnR3VzU3ZNYmtFbDRMNktXVHlvZ0pTa0V4blRBMERITmp6RTRsUmE2cURPNFEvR3hIOE13ZjZKNU1STTlMVGI0CjQvenlNMnE1T1RIRnI4U05EUjFrRmpPcStvUXB0dFFMd05oOXc1TUNBd0VBQWFPQ0FaSXdnZ0dPTUJJR0ExVWQKRXdFQi93UUlNQVlCQWY4Q0FRQXdEZ1lEVlIwUEFRSC9CQVFEQWdHR01IOEdDQ3NHQVFVRkJ3RUJCSE13Y1RBeQpCZ2dyQmdFRkJRY3dBWVltYUhSMGNEb3ZMMmx6Y21jdWRISjFjM1JwWkM1dlkzTndMbWxrWlc1MGNuVnpkQzVqCmIyMHdPd1lJS3dZQkJRVUhNQUtHTDJoMGRIQTZMeTloY0hCekxtbGtaVzUwY25WemRDNWpiMjB2Y205dmRITXYKWkhOMGNtOXZkR05oZURNdWNEZGpNQjhHQTFVZEl3UVlNQmFBRk1TbnNhUjdMSEg2MitGTGtIWC94QlZnaFlrUQpNRlFHQTFVZElBUk5NRXN3Q0FZR1o0RU1BUUlCTUQ4R0N5c0dBUVFCZ3Q4VEFRRUJNREF3TGdZSUt3WUJCUVVICkFnRVdJbWgwZEhBNkx5OWpjSE11Y205dmRDMTRNUzVzWlhSelpXNWpjbmx3ZEM1dmNtY3dQQVlEVlIwZkJEVXcKTXpBeG9DK2dMWVlyYUhSMGNEb3ZMMk55YkM1cFpHVnVkSEoxYzNRdVkyOXRMMFJUVkZKUFQxUkRRVmd6UTFKTQpMbU55YkRBVEJnTlZIUjRFRERBS29RZ3dCb0lFTG0xcGJEQWRCZ05WSFE0RUZnUVVxRXBxWXdSOTNicm0wVG0zCnBrVmw3L09vN0tFd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQkFOSElJa3VzNytNSmlaWlFzWTE0Y0NvQkcxaGQKdjBKMjAvRnlXbzVwcG5makw3OFMyazRzMkdMUko3aUQ5WkRLRXJuZHZiTkZHY3NXKzlrS0svVG5ZMjFocDREZApJVHY4UzlaWVE3b2FvcXM3SHdoRU1ZOXNpYkVENGFYdzA5eHJKWlRDOXpLMXVJZlc2dDVkSFFqdU9XditISG9XClpudXB5eHBzRVVsRWFGYisvU0NJNEtDU0JkQXNZeEFjc0hZSTV4eEVJNEx1dEhwNnMzT1QyRnVPOTBXZmRzSWsKNnE3OE9NU2RuODc1Yk5qZEJZQXF4VXAyL0xFSUhmREJrTG9RejBoRkptd0FiWWFocUthTG43M1BBQW0xWDJragpmMXc4RGRua2FiT0xHZU9WY2o5TFErczY3dkJ5a3g0YW5UalVSa2JxWnNsVUVVc24yazV4ZXVhMnpVaz0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQotLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KTUlJRmpUQ0NBM1dnQXdJQkFnSVJBT2VUa0w2U0J3TkpHRjk1ZFlIbHlvTXdEUVlKS29aSWh2Y05BUUVMQlFBdwpUekVMTUFrR0ExVUVCaE1DVlZNeEtUQW5CZ05WQkFvVElFbHVkR1Z5Ym1WMElGTmxZM1Z5YVhSNUlGSmxjMlZoCmNtTm9JRWR5YjNWd01SVXdFd1lEVlFRREV3eEpVMUpISUZKdmIzUWdXREV3SGhjTk1UVXdOakEwTVRJd01ESXcKV2hjTk1qQXdOakEwTVRJd01ESXdXakJLTVFzd0NRWURWUVFHRXdKVlV6RVdNQlFHQTFVRUNoTU5UR1YwSjNNZwpSVzVqY25sd2RERWpNQ0VHQTFVRUF4TWFUR1YwSjNNZ1JXNWpjbmx3ZENCQmRYUm9iM0pwZEhrZ1dERXdnZ0VpCk1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRQ2Mwd3p3V3VVdVI3ZHlYVGVEczJoak1PclgKTlNZWkplRzl2alh4Y0pJdnQ3aExRUVdycVo0MUNGanNzU3JFYUljTG8rTjE1T2J6cDJKeHVubUJZQi9Ya1pxZgo4OUI0WjNISWFRNlZrYy8rNXBucFlEeEl6SDdLVFhjU0pKMUhHMXJydWV3ZU53QWNuS3g3cHdYcXprcnJ2VUhsCk5waTV5LzF0UEpabzN5TXFRcEFNaG5SbnlIK2xtcmhTWVJRVFAyWHBnb2ZMMi9vT1Z2YUdpZk9GUDVlR3I3RGMKR3U5ckRaVVdmY1Fyb0dXeW1RUTJkWUJyckVyekc1QkplQytpbGs4cUlDVXBCTVowd05BeHpZOHhPSlVXdXFnegp1RVB4c1IvRE1IK2llVEVUUFMwMitPUDg4ak5xdVRreHhhL0VqUTBkWkJZenF2cUVLYmJVQzhEWWZjT1RBZ01CCkFBR2pnZ0ZuTUlJQll6QU9CZ05WSFE4QkFmOEVCQU1DQVlZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFEQlUKQmdOVkhTQUVUVEJMTUFnR0JtZUJEQUVDQVRBL0Jnc3JCZ0VFQVlMZkV3RUJBVEF3TUM0R0NDc0dBUVVGQndJQgpGaUpvZEhSd09pOHZZM0J6TG5KdmIzUXRlREV1YkdWMGMyVnVZM0o1Y0hRdWIzSm5NQjBHQTFVZERnUVdCQlNvClNtcGpCSDNkdXViUk9iZW1SV1h2ODZqc29UQXpCZ05WSFI4RUxEQXFNQ2lnSnFBa2hpSm9kSFJ3T2k4dlkzSnMKTG5KdmIzUXRlREV1YkdWMGMyVnVZM0o1Y0hRdWIzSm5NSElHQ0NzR0FRVUZCd0VCQkdZd1pEQXdCZ2dyQmdFRgpCUWN3QVlZa2FIUjBjRG92TDI5amMzQXVjbTl2ZEMxNE1TNXNaWFJ6Wlc1amNubHdkQzV2Y21jdk1EQUdDQ3NHCkFRVUZCekFDaGlSb2RIUndPaTh2WTJWeWRDNXliMjkwTFhneExteGxkSE5sYm1OeWVYQjBMbTl5Wnk4d0h3WUQKVlIwakJCZ3dGb0FVZWJSWjVudTI1ZVFCYzRBSWlNZ2FXUGJwbTI0d0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dJQgpBR3ZNL1hHdjh5YWZHUkdNUFA2aG5nZ29JOURHV0dmNGwwbXpqQmh1Q2tEVnFvRy83cnNIMXl0enRlZVB4aUEzCjdrcVNCbzBmWHU1R21iV093MDlHcHdQWXlBQVkwaVdPTVU2eWJyVEpIUzQ2NlVyem9lLzRJd0xRb1FjMjE5RUsKbGgrNFVndTFxNEt4TlkxcU1EQS8xWVgyUW05TTZBY0FzMVV2WktIU3BKUUFic1lyYk42b2JOb1VHT2VHNk9OSApZcjhLUlF6NUZNZlpZY0E0OWZtZERUd0tuL3B5TE9rSkZlQS9kbS9vUDk5VW1LQ0ZvZU9hNXc5WUpyMlZpN2ljClhkNTlDVThtcHJXaHhGWG5tYTFvVTNUOFpOb3ZqaWIzVUhvY2psRUpmTmJEeTl6Z0tUWVVSY01Wd2VvMWRrYkgKTmJMYzVtSWpJay9rSitSUEQrY2hSK2dKankzR2g5eE1Oa0RyWlFLZnNJTzkzaHhUc1pNbWdaUTRjK3Z1akMxTQpqU2FrK0FpODdZWmVZUVBoMWZDR01TVG5vNUlJSTM3RFVDdEluOEJKeEppeHVQZU9NS3NqTExENUF0TVZ5MGZwCmQxOWxjVWVrNGJqRFk4L1VqYjUvd2ZuMitLazd6NzJTeFdkZWtqdEhPV0JtS3hxcThqRHV1TXc0eW1nMWc1bjcKUjdUWi9ZM3k0YlRwV1VEa0JIRm8wM3hOTTIxd0JGRElyQ1paZVZodkRXNE10VDYrQXNzMmJjcG9Id1ljR29sMgpnYUxEYTVrMmRrRzQxT0d0WGEwZlkrVGpkcnlZNGNPY3N0SlVLanYyTUprdTR5YVR0ampFQ1gxckp2RkxucVllCndDK0ZteGpnV1B1eVJOdUxEQVdLMzBtbXBjSlozQ21ENmRGdEFpNGg3SDM3Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUdiVENDQlZXZ0F3SUJBZ0lRUUFGNTJWaFpYOXdSdzNKelYra0R2akFOQmdrcWhraUc5dzBCQVFzRkFEQS8KTVNRd0lnWURWUVFLRXh0RWFXZHBkR0ZzSUZOcFoyNWhkSFZ5WlNCVWNuVnpkQ0JEYnk0eEZ6QVZCZ05WQkFNVApEa1JUVkNCU2IyOTBJRU5CSUZnek1CNFhEVEl4TURZd05ESXpNalV4TmxvWERUSTBNRGt6TURJek1qVXhObG93ClNqRUxNQWtHQTFVRUJoTUNWVk14RWpBUUJnTlZCQW9UQ1Vsa1pXNVVjblZ6ZERFbk1DVUdBMVVFQXhNZVNXUmwKYmxSeWRYTjBJRU52YlcxbGNtTnBZV3dnVW05dmRDQkRRU0F4TUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQwpBZzhBTUlJQ0NnS0NBZ0VBcDFBWjNqK1pQZFF6UnZGdlVXR0NzcWxQajJlSlhZVFpVOTBNS05uWDhQK3VsVU55Cm1mbTFYWHlLd1VMaE1WQjAwWUVOZk0yYklhdEQ0cXl0WG9adTh3bUtIMW95dmFMcmxQbm9YQXJzLzVqU3IzR3oKdEZPZlRvZnZrcnk5N0U4eU1JaExGMTVYeEZQQzlnS1hqZGxpSzc4a0gyS04zOE80S1V0SmVEeVRZSWdpL0puYQpOc2pDb3RRc1ZBQm5OVzV6dndKWThLVGQ1YkNpSm5ySzREYWxHUmIxL2JmdnJqOUE5VzFhQlAzT05Nb2szSFFqCkcxMHpFeEpkeEFFbDlqRGRBbDJmNE5WSHZiVHJHNkc3U1VuWW4xc0M4NHJrSkpEa1lrOVB3YStMRG5RWHFORnkKaUdwNkFVbk10RVo1eGhleDJwZ2VCMW42ZFNHRlpkMlFWczc3cTZWZ25jU2QrVkt3aTcySCtZOHJJd29qZGp2MwpNK0hKQVBOcCtVdWk0RTY4ZnBNNWhBZjNSSEIrL2dkYTViR3MwUmpNOGpYbFNVa0l5bGJKUGZzUEdIMkxPOEVUCndrMlB5VThPTitrZm9RNXEzMkl1eXpVR1VYa3N5Q1U0OVBwTHA0bGNuTkxqRFRtR1NuUjgxVm1Id2o5T0RGeFMKOUQzM1VvTHg2cU9zL1VrMEdpanpRWWc2RSs3bzN2K1pIVis2eStnZThybFFZTUF4MDNQbDc3Nmc3VE1MZEw0ZwpJTVJuYlBBSUEzcFZnSDlHVHBhbjlCNCs0ZmJZQ2VFelpDdGoxekplbi9uQWV3OTRiNWU4azVyNW5CS1FlSHFBCmh4WFhjblNjVlhSNHNicmhibkFFdWsrZ3VtakRlLzh4OEhNOVBaUXFzUXRCRHFEK1RZaGxhM2t6dE5jQ0F3RUEKQWFPQ0FsZ3dnZ0pVTUJJR0ExVWRFd0VCL3dRSU1BWUJBZjhDQVFFd0RnWURWUjBQQVFIL0JBUURBZ0VHTUZFRwpDQ3NHQVFVRkJ3RUJCRVV3UXpCQkJnZ3JCZ0VGQlFjd0FvWTFhSFIwY0RvdkwzWmhiR2xrWVhScGIyNHVhV1JsCmJuUnlkWE4wTG1OdmJTOXliMjkwY3k5a2MzUnliMjkwWTJGNE15NXdOMk13SHdZRFZSMGpCQmd3Rm9BVXhLZXgKcEhzc2NmcmI0VXVRZGYvRUZXQ0ZpUkF3Z2dFOEJnTlZIU0FFZ2dFek1JSUJMekNDQVNFR0NtQ0dTQUdHK1M4QQpCZ013Z2dFUk1Fb0dDQ3NHQVFVRkJ3SUJGajVvZEhSd2N6b3ZMM05sWTNWeVpTNXBaR1Z1ZEhKMWMzUXVZMjl0CkwyTmxjblJwWm1sallYUmxjeTl3YjJ4cFkza3ZkSE12YVc1a1pYZ3VhSFJ0YkRDQndnWUlLd1lCQlFVSEFnSXcKZ2JVTWdiSlVhR2x6SUZSeWRYTjBTVVFnVTJWeWRtVnlJRU5sY25ScFptbGpZWFJsSUdoaGN5QmlaV1Z1SUdsegpjM1ZsWkNCcGJpQmhZMk52Y21SaGJtTmxJSGRwZEdnZ1NXUmxibFJ5ZFhOMEozTWdWSEoxYzNSSlJDQkRaWEowCmFXWnBZMkYwWlNCUWIyeHBZM2tnWm05MWJtUWdZWFFnYUhSMGNITTZMeTl6WldOMWNtVXVhV1JsYm5SeWRYTjAKTG1OdmJTOGdZMlZ5ZEdsbWFXTmhkR1Z6TDNCdmJHbGplUzkwY3k5cGJtUmxlQzVvZEcxc01BZ0dCbWVCREFFQwpBakE4QmdOVkhSOEVOVEF6TURHZ0w2QXRoaXRvZEhSd09pOHZZM0pzTG1sa1pXNTBjblZ6ZEM1amIyMHZSRk5VClVrOVBWRU5CV0RORFVrd3VZM0pzTUIwR0ExVWREZ1FXQkJUdFJCbkEwL0FHaSs2a2U3NUM1eVpVeUk0MmRqQWQKQmdOVkhTVUVGakFVQmdnckJnRUZCUWNEQVFZSUt3WUJCUVVIQXdJd0RRWUpLb1pJaHZjTkFRRUxCUUFEZ2dFQgpBSmE5MTBvK3p4SGJ6ckgxNWYrVzJMKzRWVlBpaU5rYWUxSVBndmdjYnQ0YjlGeThqOEhRbnlCa1ZMdFRTdmxTCmdROUZXL0JYVGxHbHExYTZ1YWFnVUZDaUsyRkEzcVB1RDM2NlJvRGIvOVlYTWRwRzJmUjBMdW1aSVhwS3VkV2oKYTNQTFRsMWtDRHFsa2poK2pPRHFKY2MrTFB0aC9JTnBmQmoyTWZuMWhOSnZsVmV1Nmc3L05oL3FVcDYxWENnUQpsVUtRMkliNEYzTk40bmdnYVF1MkRmWjVnUjU5d0h6dzl3bFJLeC9lK0RVclZBMFUyMkk3UFBFZVN1cXUwSGlZCm50TU1jRU5UcmJGaFdIVU12bHlNbVRsb08zKzZzRjRLcVpYcW43SGFCOW1aSllDMTdYbDA2c1JpQTA0YlZCaXkKdTBUMEJrb2lzYUdySFZRaDJlQVFITzg9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
  dhparam.pem: LS0tLS1CRUdJTiBESCBQQVJBTUVURVJTLS0tLS0KTUlJQkNBS0NBUUVBLy8vLy8vLy8vLyt0K0ZSWW9ydEttcS9jVmlBblBUengyTG5GZzg0dE5wV3A0VFpCRkdRegorOHlUbmM0a216NzVmUy9qWTJNTWRkajJnYklDcnNSaGV0UGZIdFhWL1dWaEpEUDFIMThHYnRDRlkyVlZQZTBhCjg3VlhFMTUvVjhrMW1FOE1jT0RtaTNmaXBvbmE4Ky9vY2gzeFdLRTJyZWMxTUt6S1QwZzZlWHE4Q3JHQ3N5VDcKWWRFSXFVdXl5T1A3dVdyYXQyRFg5R2dkVDBLajNqbE45SzVXN2VkamNyc1pDd2VueU80S2JYQ2VBdnpoemZmaQo3TUEwQk0wb05DOWhrWEwrbk9tRmcvK09UeEl5N3ZLQmc4UCtPeHRNYjYxek83WDh2QzdDSUFYRmp2R0RmUmFECnNzYnpTaWJCc3UvNmlHdENPR0VvWEpmLy8vLy8vLy8vL3dJQkFnPT0KLS0tLS1FTkQgREggUEFSQU1FVEVSUy0tLS0t
  certificate.conf: WyByZXEgXQpkaXN0aW5ndWlzaGVkX25hbWUgPSByZXFfZGlzdGluZ3Vpc2hlZF9uYW1lCnByb21wdCAgICAgICAgICAgICA9IG5vCgpbIHJlcV9kaXN0aW5ndWlzaGVkX25hbWUgXQpPICAgICAgICAgICAgICAgICAgPSBNYWluIE9yZy4K
#certs: {}

## @section PMM network configuration
## Service configuration
##
service:
  ## @param service.name Service name that is dns name monitoring services would send data to. `monitoring-service` used by default by pmm-client in Percona operators.
  ##
  name: monitoring-service
  ## @param service.type Kubernetes Service type
  ##
  type: NodePort

  ## Ports 443 and/or 80
  ##
  ports:
    ## @param service.ports[0].port https port number
    - port: 443
      ## @param service.ports[0].targetPort target port to map for statefulset and ingress
      targetPort: https
      ## @param service.ports[0].protocol protocol for https
      protocol: TCP
      ## @param service.ports[0].name port name
      name: https
    ## @param service.ports[1].port http port number
    - port: 80
      ## @param service.ports[1].targetPort target port to map for statefulset and ingress
      targetPort: http
      ## @param service.ports[1].protocol protocol for http
      protocol: TCP
      ## @param service.ports[1].name port name
      name: http

## Ingress controller configuration
##
ingress:
  ## @param ingress.enabled -- Enable ingress controller resource
  enabled: false
  ## @param ingress.nginxInc -- Using ingress controller from NGINX Inc
  nginxInc: false
  ## @param ingress.annotations -- Ingress annotations configuration
  annotations: {}
    ## kubernetes.io/ingress.class: nginx
    ## kubernetes.io/tls-acme: "true"
    ###  nginx proxy to https
    ## nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
  ## @param ingress.community.annotations -- Ingress annotations configuration for community managed ingress (nginxInc = false)
  community:
    annotations: {}
      ## kubernetes.io/ingress.class: nginx
      ## kubernetes.io/tls-acme: "true"
  ## @param ingress.ingressClassName -- Sets the ingress controller class name to use.
  ingressClassName: ""

  ## Ingress resource hostnames and path mappings
  hosts:
    ## @param ingress.hosts[0].host hostname
    - host: chart-example.local
    ## @param ingress.hosts[0].paths path mapping
      paths: []

  ## @param ingress.pathType -- How ingress paths should be treated.
  pathType: Prefix

  ## @param ingress.tls -- Ingress TLS configuration
  tls: []
  ##  - secretName: chart-example-tls
  ##    hosts:
  ##      - chart-example.local

## @section PMM storage configuration
## Claiming storage for PMM using Persistent Volume Claims (PVC)
## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
##
storage:
  ## @param storage.name name of PVC
  name: pmm-storage
  ## @param storage.storageClassName optional PMM data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  storageClassName: ""
  ##
  ## @param storage.size size of storage [depends](https://docs.percona.com/percona-monitoring-and-management/setting-up/server/index.html#set-up-pmm-server) on number of monitored services and data retention
  ##
  size: 10Gi
  ##
  ## @param storage.dataSource VolumeSnapshot to start from
  ##
  dataSource: {}
    ## name: before-vX.Y.Z-upgrade
    ## kind: VolumeSnapshot
    ## apiGroup: snapshot.storage.k8s.io
  ##
  ## @param storage.selector select existing PersistentVolume
  ##
  selector: {}
  ##   matchLabels:
  ##     release: "stable"
  ##   matchExpressions:
  ##     - key: environment
  ##       operator: In
  ##       values:
  ##         - dev

## @section PMM kubernetes configurations
## @param nameOverride String to partially override common.names.fullname template with a string (will prepend the release name)
##
nameOverride: ""

## @param namespaceOverride String to override namespace. Defaults to the value of .Release.Namespace.
##
namespaceOverride: ""

## @param extraLabels Labels to add to all deployed objects
##
extraLabels: {}

## Pods Service Account
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
## @param serviceAccount.create Specifies whether a ServiceAccount should be created
## @param serviceAccount.annotations Annotations for service account. Evaluated as a template. Only used if `create` is `true`.
## @param serviceAccount.name Name of the service account to use. If not set and create is true, a name is generated using the fullname template.
##
serviceAccount:
  create: false
  annotations: {}
#  name: "pmm-service-account"

## @param podAnnotations Pod annotations
## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
##
podAnnotations: {}

## @param podSecurityContext Configure Pods Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
## E.g
podSecurityContext:
#  runAsUser: 1000
#  runAsGroup: 1000
#  fsGroupChangePolicy: OnRootMismatch
#  fsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault


## @param securityContext Configure Container Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
## securityContext.capabilities The capabilities to add/drop when running containers
## securityContext.runAsUser Set pmm containers' Security Context runAsUser
## securityContext.runAsNonRoot Set pmm container's Security Context runAsNonRoot
## E.g.
## securityContext:
  ## capabilities:
  ##   drop:
  ##   - ALL
  ## readOnlyRootFilesystem: true
  ## runAsNonRoot: true
  ## runAsUser: 1000
securityContext:
    capabilities:
        drop:
        - ALL
    allowPrivilegeEscalation: false


## @param nodeSelector Node labels for pod assignment
## Ref: https://kubernetes.io/docs/user-guide/node-selection/
##
nodeSelector: {}

## @param tolerations Tolerations for pod assignment
## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: []

## @param affinity Affinity for pod assignment
## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
affinity: {}

## @param extraVolumeMounts Optionally specify extra list of additional volumeMounts
##
extraVolumeMounts: []
## @param extraVolumes Optionally specify extra list of additional volumes
##
extraVolumes: []
